{
  "version": "1.1.0",
  "last_updated": "2024-11-27",
  "description": "Enterprise Runbook Registry for AI-Driven Incident Remediation",
  "scripts": [
    {
      "id": "ansible-restart-airflow-scheduler",
      "name": "Restart Airflow Scheduler",
      "path": "ansible/restart_airflow_scheduler.yml",
      "type": "ansible",
      "service": "airflow",
      "action": "restart",
      "component": "scheduler",
      "keywords": ["scheduler", "heartbeat", "down", "missing", "restart", "airflow", "dag", "task", "worker"],
      "error_patterns": [
        "scheduler.*heartbeat.*missing",
        "scheduler.*down",
        "airflow.*scheduler.*not.*respond",
        "dag.*not.*scheduled",
        "no.*heartbeat.*from.*scheduler"
      ],
      "risk": "medium",
      "requires_approval": true,
      "estimated_time_minutes": 5,
      "rollback_script": "ansible/stop_airflow_scheduler.yml",
      "pre_checks": ["verify_airflow_installed", "check_scheduler_status", "capture_pid"],
      "post_checks": ["verify_process_running", "verify_heartbeat", "check_logs"],
      "dependencies": ["systemd", "airflow"],
      "tags": ["airflow", "scheduler", "restart", "data-pipeline"]
    },
    {
      "id": "ansible-fix-database-cpu",
      "name": "Fix Database High CPU",
      "path": "ansible/fix_database_cpu.yml",
      "type": "ansible",
      "service": "database",
      "action": "optimize",
      "component": "postgresql",
      "keywords": ["database", "cpu", "high", "spike", "slow", "queries", "postgresql", "mysql", "optimization", "vacuum", "index"],
      "error_patterns": [
        "database.*cpu.*high",
        "high.*cpu.*database",
        "slow.*query",
        "query.*timeout",
        "connection.*pool.*exhausted",
        "too.*many.*connections"
      ],
      "risk": "medium",
      "requires_approval": true,
      "estimated_time_minutes": 15,
      "rollback_script": "ansible/rollback_db_optimization.yml",
      "pre_checks": ["capture_cpu", "get_connections", "identify_long_queries"],
      "post_checks": ["verify_cpu_reduced", "verify_connections", "verify_db_responding"],
      "dependencies": ["postgresql", "psql"],
      "tags": ["database", "postgresql", "cpu", "optimization", "performance"]
    },
    {
      "id": "ansible-restart-kubernetes-pod",
      "name": "Restart Kubernetes Pod",
      "path": "ansible/restart_kubernetes_pod.yml",
      "type": "ansible",
      "service": "kubernetes",
      "action": "restart",
      "component": "pod",
      "keywords": ["pod", "restart", "crashloop", "oom", "killed", "kubernetes", "k8s", "deployment", "container", "crashloopbackoff"],
      "error_patterns": [
        "pod.*crash",
        "crashloopbackoff",
        "oomkilled",
        "container.*restart",
        "pod.*not.*ready",
        "liveness.*probe.*failed"
      ],
      "risk": "low",
      "requires_approval": false,
      "estimated_time_minutes": 3,
      "rollback_script": "ansible/scale_deployment.yml",
      "pre_checks": ["verify_kubectl", "get_pod_status", "get_replicas"],
      "post_checks": ["verify_pods_running", "check_pod_logs"],
      "dependencies": ["kubectl", "kubernetes"],
      "tags": ["kubernetes", "pod", "restart", "deployment", "container"]
    },
    {
      "id": "script-clear-disk-space",
      "name": "Clear Disk Space",
      "path": "scripts/clear_disk_space.sh",
      "type": "shell",
      "service": "infrastructure",
      "action": "cleanup",
      "component": "disk",
      "keywords": ["disk", "space", "full", "cleanup", "logs", "temp", "storage", "filesystem", "no space left"],
      "error_patterns": [
        "disk.*full",
        "no.*space.*left",
        "filesystem.*full",
        "cannot.*write",
        "disk.*quota.*exceeded"
      ],
      "risk": "low",
      "requires_approval": false,
      "estimated_time_minutes": 5,
      "rollback_script": null,
      "pre_checks": ["check_disk_usage", "identify_large_directories"],
      "post_checks": ["verify_space_freed", "verify_disk_below_threshold"],
      "dependencies": ["bash", "find", "df"],
      "tags": ["disk", "cleanup", "storage", "maintenance"]
    },
    {
      "id": "ansible-restart-nginx",
      "name": "Restart Nginx Web Server",
      "path": "ansible/restart_nginx.yml",
      "type": "ansible",
      "service": "webserver",
      "action": "restart",
      "component": "nginx",
      "keywords": ["nginx", "web", "server", "502", "504", "gateway", "timeout", "connection refused"],
      "error_patterns": [
        "502.*bad.*gateway",
        "504.*gateway.*timeout",
        "nginx.*not.*running",
        "connection.*refused.*nginx"
      ],
      "risk": "low",
      "requires_approval": false,
      "estimated_time_minutes": 2,
      "rollback_script": null,
      "pre_checks": ["verify_nginx_config", "check_nginx_status"],
      "post_checks": ["verify_nginx_running", "verify_ports_listening"],
      "dependencies": ["nginx", "systemd"],
      "tags": ["nginx", "webserver", "restart", "gateway"]
    },
    {
      "id": "ansible-scale-gcp-instance",
      "name": "Scale GCP VM Instance",
      "path": "ansible/scale_gcp_instance.yml",
      "type": "ansible",
      "service": "gcp",
      "action": "scale",
      "component": "compute",
      "keywords": ["gcp", "vm", "instance", "scale", "resize", "memory", "cpu", "compute", "machine type"],
      "error_patterns": [
        "instance.*out.*of.*memory",
        "vm.*memory.*exhausted",
        "cpu.*throttled",
        "resource.*limit"
      ],
      "risk": "high",
      "requires_approval": true,
      "estimated_time_minutes": 10,
      "rollback_script": "ansible/revert_gcp_instance.yml",
      "pre_checks": ["verify_gcloud_auth", "get_instance_status", "capture_current_type"],
      "post_checks": ["verify_instance_running", "verify_new_specs"],
      "dependencies": ["gcloud", "ansible-gcp"],
      "tags": ["gcp", "vm", "scale", "compute", "resize"]
    },
    {
      "id": "script-start-gcp-instance",
      "name": "Start GCP VM Instance",
      "path": "scripts/start_gcp_instance.sh",
      "type": "shell",
      "service": "gcp",
      "action": "start",
      "component": "compute",
      "keywords": ["gcp", "vm", "instance", "start", "terminated", "stopped", "boot", "compute", "google cloud", "power on"],
      "error_patterns": [
        "instance.*terminated",
        "instance.*stopped",
        "vm.*not.*running",
        "instance.*down",
        "vm.*terminated",
        "compute.*instance.*stopped"
      ],
      "risk": "low",
      "requires_approval": false,
      "estimated_time_minutes": 3,
      "rollback_script": "scripts/stop_gcp_instance.sh",
      "pre_checks": ["verify_gcloud_auth", "verify_instance_exists", "get_instance_status"],
      "post_checks": ["verify_instance_running", "verify_network_connectivity"],
      "dependencies": ["gcloud", "bash"],
      "tags": ["gcp", "vm", "start", "compute", "instance"]
    },
    {
      "id": "terraform-create-firewall-rule",
      "name": "Create GCP Firewall Rule",
      "path": "terraform/gcp_firewall.tf",
      "type": "terraform",
      "service": "gcp",
      "action": "create",
      "component": "firewall",
      "keywords": ["firewall", "network", "security", "ingress", "egress", "port", "allow", "deny"],
      "error_patterns": [
        "connection.*timed.*out",
        "network.*unreachable",
        "port.*blocked"
      ],
      "risk": "critical",
      "requires_approval": true,
      "estimated_time_minutes": 5,
      "rollback_script": "terraform/destroy_firewall.tf",
      "pre_checks": ["terraform_plan", "verify_network_exists"],
      "post_checks": ["verify_rule_created", "test_connectivity"],
      "dependencies": ["terraform", "gcloud"],
      "tags": ["gcp", "firewall", "network", "security"]
    },
    {
      "id": "ansible-flush-redis-cache",
      "name": "Flush Redis Cache",
      "path": "ansible/flush_redis_cache.yml",
      "type": "ansible",
      "service": "cache",
      "action": "flush",
      "component": "redis",
      "keywords": ["redis", "cache", "flush", "clear", "memory", "stale", "expired"],
      "error_patterns": [
        "cache.*stale",
        "redis.*memory.*full",
        "cache.*inconsistent"
      ],
      "risk": "medium",
      "requires_approval": true,
      "estimated_time_minutes": 2,
      "rollback_script": null,
      "pre_checks": ["verify_redis_running", "capture_memory_usage"],
      "post_checks": ["verify_cache_cleared", "verify_redis_responding"],
      "dependencies": ["redis-cli", "redis"],
      "tags": ["redis", "cache", "flush", "memory"]
    },
    {
      "id": "ansible-fix-nginx-502",
      "name": "Fix Nginx 502 Bad Gateway",
      "path": "ansible/fix_nginx_502.yml",
      "type": "ansible",
      "service": "nginx",
      "action": "restart",
      "component": "gateway",
      "keywords": ["nginx", "502", "gateway", "upstream", "proxy", "web", "server", "bad gateway"],
      "error_patterns": [
        "502.*bad.*gateway",
        "nginx.*upstream.*failed",
        "connect.*refused",
        "upstream.*timed.*out"
      ],
      "risk": "medium",
      "requires_approval": true,
      "estimated_time_minutes": 10,
      "rollback_script": "ansible/rollback_nginx.yml",
      "pre_checks": ["check_nginx_status", "check_upstream_health"],
      "post_checks": ["verify_nginx_running", "test_endpoint"],
      "dependencies": ["nginx", "systemd"],
      "tags": ["nginx", "502", "gateway", "web", "proxy"]
    },
    {
      "id": "ansible-fix-memory-leak",
      "name": "Fix Memory Leak - Service Restart",
      "path": "ansible/fix_memory_leak.yml",
      "type": "ansible",
      "service": "application",
      "action": "restart",
      "component": "memory",
      "keywords": ["memory", "leak", "oom", "ram", "heap", "gc", "restart", "out of memory"],
      "error_patterns": [
        "out.*of.*memory",
        "oom.*killer",
        "memory.*exhausted",
        "cannot.*allocate",
        "memory.*leak"
      ],
      "risk": "medium",
      "requires_approval": true,
      "estimated_time_minutes": 15,
      "rollback_script": "ansible/emergency_restart.yml",
      "pre_checks": ["capture_memory_usage", "check_service_health"],
      "post_checks": ["verify_memory_reduced", "verify_service_healthy"],
      "dependencies": ["systemd"],
      "tags": ["memory", "leak", "oom", "restart", "application"]
    },
    {
      "id": "terraform-scale-gcp-instance",
      "name": "Scale GCP Compute Instance",
      "path": "terraform/scale_gcp_instance.tf",
      "type": "terraform",
      "service": "gcp",
      "action": "scale",
      "component": "compute",
      "keywords": ["gcp", "vm", "instance", "scale", "resize", "cpu", "memory", "compute", "machine type"],
      "error_patterns": [
        "instance.*cpu.*high",
        "vm.*overloaded",
        "compute.*throttling",
        "instance.*out.*of.*memory"
      ],
      "risk": "medium",
      "requires_approval": true,
      "estimated_time_minutes": 15,
      "rollback_script": "terraform/rollback_instance_scale.tf",
      "pre_checks": ["verify_instance_exists", "capture_current_size"],
      "post_checks": ["verify_new_size", "check_instance_health"],
      "dependencies": ["terraform", "gcloud"],
      "tags": ["gcp", "vm", "scale", "compute", "resize"]
    },
    {
      "id": "k8s-restart-deployment",
      "name": "Restart Kubernetes Deployment",
      "path": "kubernetes/restart_deployment.yaml",
      "type": "kubernetes",
      "service": "kubernetes",
      "action": "restart",
      "component": "deployment",
      "keywords": ["kubernetes", "k8s", "deployment", "restart", "pods", "rolling", "rollout"],
      "error_patterns": [
        "pod.*crash",
        "container.*error",
        "deployment.*unhealthy",
        "crashloopbackoff"
      ],
      "risk": "low",
      "requires_approval": false,
      "estimated_time_minutes": 5,
      "rollback_script": "kubernetes/rollback_deployment.yaml",
      "pre_checks": ["verify_deployment_exists", "check_current_pods"],
      "post_checks": ["verify_pods_running", "check_rollout_status"],
      "dependencies": ["kubectl"],
      "tags": ["kubernetes", "k8s", "deployment", "restart", "rolling"]
    },
    {
      "id": "k8s-scale-deployment",
      "name": "Scale Kubernetes Deployment",
      "path": "kubernetes/scale_deployment.yaml",
      "type": "kubernetes",
      "service": "kubernetes",
      "action": "scale",
      "component": "deployment",
      "keywords": ["kubernetes", "k8s", "scale", "replicas", "deployment", "load", "capacity", "hpa"],
      "error_patterns": [
        "high.*load",
        "response.*time.*slow",
        "queue.*backed.*up",
        "replicas.*insufficient"
      ],
      "risk": "low",
      "requires_approval": false,
      "estimated_time_minutes": 3,
      "rollback_script": null,
      "pre_checks": ["verify_deployment_exists", "check_current_replicas"],
      "post_checks": ["verify_replicas_running", "check_pod_health"],
      "dependencies": ["kubectl"],
      "tags": ["kubernetes", "k8s", "scale", "replicas", "hpa"]
    },
    {
      "id": "pipeline-restart-airflow-dag",
      "name": "Restart Failed Airflow DAG",
      "path": "pipelines/restart_airflow_dag.yaml",
      "type": "kubernetes",
      "service": "airflow",
      "action": "restart",
      "component": "dag",
      "keywords": ["airflow", "dag", "pipeline", "task", "failed", "retry", "clear", "data pipeline"],
      "error_patterns": [
        "dag.*failed",
        "task.*failed",
        "airflow.*error",
        "dag.*stuck"
      ],
      "risk": "low",
      "requires_approval": false,
      "estimated_time_minutes": 5,
      "rollback_script": null,
      "pre_checks": ["check_dag_exists", "verify_airflow_running"],
      "post_checks": ["verify_dag_running", "check_task_status"],
      "dependencies": ["airflow", "kubectl"],
      "tags": ["airflow", "dag", "pipeline", "restart", "data"]
    },
    {
      "id": "shell-check-restart-service",
      "name": "Check and Restart Service",
      "path": "scripts/check_and_restart_service.sh",
      "type": "shell",
      "service": "generic",
      "action": "restart",
      "component": "service",
      "keywords": ["service", "restart", "health", "check", "systemd", "process", "generic"],
      "error_patterns": [
        "service.*down",
        "health.*check.*failed",
        "not.*responding",
        "service.*not.*running"
      ],
      "risk": "low",
      "requires_approval": false,
      "estimated_time_minutes": 5,
      "rollback_script": null,
      "pre_checks": ["check_service_exists"],
      "post_checks": ["verify_service_running"],
      "dependencies": ["systemd", "bash"],
      "tags": ["service", "restart", "health", "generic"]
    }
  ],
  "risk_levels": {
    "low": {
      "description": "Safe to execute automatically",
      "requires_approval": false,
      "examples": ["restart pod", "flush cache", "clear logs"]
    },
    "medium": {
      "description": "Requires human review before execution",
      "requires_approval": true,
      "examples": ["restart service", "scale resources", "database optimization"]
    },
    "high": {
      "description": "Requires Senior SRE + on-call lead approval",
      "requires_approval": true,
      "approvers": ["senior-sre", "oncall-lead"],
      "examples": ["terraform changes", "database failover"]
    },
    "critical": {
      "description": "Requires 2-person approval",
      "requires_approval": true,
      "approvers": ["senior-sre", "oncall-lead", "manager"],
      "examples": ["firewall changes", "production database changes"]
    }
  }
}
