"""
Dynamic Solution Generator
LLM generates Terraform/Ansible scripts on-the-fly based on incident analysis
No hardcoded solutions - everything generated by AI with RAG context
"""
import os
import sys
from typing import Any, Dict, List, Optional
from datetime import datetime
import structlog
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
import httpx
import json

sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(__file__))))

from backend.rag.hybrid_search import hybrid_rag

logger = structlog.get_logger()


class DynamicSolutionGenerator:
    """
    Generates infrastructure-as-code solutions dynamically using LLM + RAG
    This is how industry does it - no hardcoded scripts
    """

    def __init__(self):
        self.llm = ChatOpenAI(model="gpt-4", temperature=0.1)
        self.rag = hybrid_rag

        # GitHub API
        self.github_token = os.getenv("GITHUB_TOKEN")
        self.github_org = os.getenv("GITHUB_ORG", "sam2881")
        self.github_repo = os.getenv("GITHUB_REPO", "test_01")

        # Jira API
        self.jira_url = os.getenv("JIRA_URL")
        self.jira_username = os.getenv("JIRA_USERNAME")
        self.jira_token = os.getenv("JIRA_API_TOKEN")
        self.jira_project = os.getenv("JIRA_PROJECT_KEY", "ENG")

    async def generate_terraform_solution(
        self,
        incident_analysis: Dict[str, Any],
        rag_context: Dict[str, Any]
    ) -> Dict[str, Any]:
        """
        LLM generates Terraform script based on incident
        NOT hardcoded - dynamically created per incident
        """
        logger.info("generating_terraform_solution", incident=incident_analysis.get("issue_category"))

        # Get similar solutions from RAG
        similar_incidents = rag_context.get("similar_incidents", [])
        similar_solutions = "\n\n".join([
            f"Incident: {inc.get('title')}\nSolution: {inc.get('resolution')}"
            for inc in similar_incidents[:3]
        ])

        prompt = ChatPromptTemplate.from_messages([
            ("system", """You are an expert DevOps engineer specializing in Infrastructure-as-Code.

Generate a complete, production-ready Terraform script to resolve the given GCP incident.

Guidelines:
1. Use proper Terraform syntax (HCL)
2. Include variables for flexibility
3. Add comments explaining each resource
4. Use best practices (remote state, proper naming)
5. Include outputs for verification
6. Make it idempotent and safe

Based on similar incidents from RAG:
{similar_solutions}

Incident Details:
{incident_details}

Generate ONLY the Terraform code. Include:
- provider.tf
- variables.tf
- main.tf
- outputs.tf

Wrap each file in markdown code blocks with filename."""),
            ("human", "Generate the Terraform solution for this incident.")
        ])

        chain = prompt | self.llm

        try:
            response = chain.invoke({
                "similar_solutions": similar_solutions or "No similar solutions found",
                "incident_details": json.dumps(incident_analysis, indent=2)
            })

            # Parse generated Terraform files
            terraform_files = self._parse_generated_files(response.content, "tf")

            return {
                "success": True,
                "files": terraform_files,
                "raw_response": response.content
            }

        except Exception as e:
            logger.error("terraform_generation_error", error=str(e))
            return {"success": False, "error": str(e)}

    async def generate_ansible_solution(
        self,
        incident_analysis: Dict[str, Any],
        rag_context: Dict[str, Any],
        vm_ip: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        LLM generates Ansible playbook based on incident
        NOT hardcoded - dynamically created per incident
        """
        logger.info("generating_ansible_solution", incident=incident_analysis.get("issue_category"))

        similar_incidents = rag_context.get("similar_incidents", [])
        similar_solutions = "\n\n".join([
            f"Incident: {inc.get('title')}\nSolution: {inc.get('resolution')}"
            for inc in similar_incidents[:3]
        ])

        prompt = ChatPromptTemplate.from_messages([
            ("system", """You are an expert DevOps engineer specializing in Configuration Management.

Generate a complete, production-ready Ansible playbook to resolve the given incident.

Guidelines:
1. Use proper YAML syntax
2. Include error handling and idempotency
3. Add comments and task descriptions
4. Include health checks and verification
5. Use best practices (handlers, tags, when conditions)
6. Make it reusable with variables

Based on similar incidents from RAG:
{similar_solutions}

Incident Details:
{incident_details}

VM IP: {vm_ip}

Generate the Ansible playbook. Include:
- playbook.yml (main playbook)
- inventory.ini (if needed)

Wrap each file in markdown code blocks with filename."""),
            ("human", "Generate the Ansible solution for this incident.")
        ])

        chain = prompt | self.llm

        try:
            response = chain.invoke({
                "similar_solutions": similar_solutions or "No similar solutions found",
                "incident_details": json.dumps(incident_analysis, indent=2),
                "vm_ip": vm_ip or "{{ vm_ip }}"
            })

            # Parse generated Ansible files
            ansible_files = self._parse_generated_files(response.content, "yml")

            return {
                "success": True,
                "files": ansible_files,
                "raw_response": response.content
            }

        except Exception as e:
            logger.error("ansible_generation_error", error=str(e))
            return {"success": False, "error": str(e)}

    def _parse_generated_files(self, llm_response: str, file_extension: str) -> Dict[str, str]:
        """
        Parse LLM response to extract multiple files
        """
        files = {}
        lines = llm_response.split("\n")
        current_file = None
        current_content = []

        for line in lines:
            # Look for file markers like "### provider.tf" or "```hcl"
            if "```" in line:
                if current_file and current_content:
                    files[current_file] = "\n".join(current_content)
                    current_content = []

                # Extract filename
                if line.strip().startswith("```"):
                    lang = line.replace("```", "").strip()
                    # Look ahead for filename comment
                    current_file = None
                continue

            # Look for filename in comments
            if line.strip().startswith("#") and f".{file_extension}" in line:
                filename = line.split(".")[0].strip("#").strip() + f".{file_extension}"
                current_file = filename
                continue

            # Collect file content
            if current_file:
                current_content.append(line)

        # Save last file
        if current_file and current_content:
            files[current_file] = "\n".join(current_content)

        # If no files parsed, try simple approach
        if not files:
            files[f"generated.{file_extension}"] = llm_response

        return files

    async def create_github_pr(
        self,
        terraform_files: Dict[str, str],
        ansible_files: Dict[str, str],
        incident_id: str,
        description: str
    ) -> Dict[str, Any]:
        """
        Create GitHub Pull Request with generated scripts
        Industry standard: Code review before merge
        """
        logger.info("creating_github_pr", incident_id=incident_id)

        branch_name = f"incident-{incident_id}-{int(datetime.now().timestamp())}"

        try:
            async with httpx.AsyncClient() as client:
                # 1. Get default branch SHA
                repo_response = await client.get(
                    f"https://api.github.com/repos/{self.github_org}/{self.github_repo}",
                    headers={
                        "Authorization": f"token {self.github_token}",
                        "Accept": "application/vnd.github.v3+json"
                    }
                )

                default_branch = repo_response.json().get("default_branch", "master")

                # 2. Get default branch reference
                ref_response = await client.get(
                    f"https://api.github.com/repos/{self.github_org}/{self.github_repo}/git/ref/heads/{default_branch}",
                    headers={
                        "Authorization": f"token {self.github_token}",
                        "Accept": "application/vnd.github.v3+json"
                    }
                )

                base_sha = ref_response.json()["object"]["sha"]

                # 3. Create new branch
                branch_response = await client.post(
                    f"https://api.github.com/repos/{self.github_org}/{self.github_repo}/git/refs",
                    headers={
                        "Authorization": f"token {self.github_token}",
                        "Accept": "application/vnd.github.v3+json"
                    },
                    json={
                        "ref": f"refs/heads/{branch_name}",
                        "sha": base_sha
                    }
                )

                # 4. Create files
                for filename, content in {**terraform_files, **ansible_files}.items():
                    folder = "terraform" if filename.endswith(".tf") else "ansible"
                    file_path = f"incident-fixes/{incident_id}/{folder}/{filename}"

                    await client.put(
                        f"https://api.github.com/repos/{self.github_org}/{self.github_repo}/contents/{file_path}",
                        headers={
                            "Authorization": f"token {self.github_token}",
                            "Accept": "application/vnd.github.v3+json"
                        },
                        json={
                            "message": f"Add {filename} for incident {incident_id}",
                            "content": self._encode_base64(content),
                            "branch": branch_name
                        }
                    )

                # 5. Create Pull Request
                pr_body = f"""## Automated Fix for Incident {incident_id}

**Incident Description:**
{description}

**Generated Solutions:**
- Terraform scripts: {len(terraform_files)} files
- Ansible playbooks: {len(ansible_files)} files

**Generated by AI Agent Platform using:**
- LLM: GPT-4
- Context: RAG (Weaviate + Neo4j)
- Incident ID: {incident_id}

**Review Checklist:**
- [ ] Terraform syntax valid
- [ ] Ansible playbook tested
- [ ] Variables properly configured
- [ ] Idempotent and safe
- [ ] Documentation included

âš ï¸ **IMPORTANT:** Review carefully before merging. Test in staging first.

ðŸ¤– Generated with AI Agent Platform
"""

                pr_response = await client.post(
                    f"https://api.github.com/repos/{self.github_org}/{self.github_repo}/pulls",
                    headers={
                        "Authorization": f"token {self.github_token}",
                        "Accept": "application/vnd.github.v3+json"
                    },
                    json={
                        "title": f"ðŸ¤– [Incident {incident_id}] Auto-generated infrastructure fix",
                        "body": pr_body,
                        "head": branch_name,
                        "base": default_branch
                    }
                )

                pr_data = pr_response.json()

                return {
                    "success": True,
                    "pr_number": pr_data.get("number"),
                    "pr_url": pr_data.get("html_url"),
                    "branch": branch_name,
                    "files_created": len(terraform_files) + len(ansible_files)
                }

        except Exception as e:
            logger.error("github_pr_error", error=str(e))
            return {"success": False, "error": str(e)}

    async def create_jira_ticket_for_tests(
        self,
        repo: str,
        python_file: str,
        incident_id: str
    ) -> Dict[str, Any]:
        """
        Create Jira ticket to write test cases
        Industry standard: Test coverage for all code
        """
        logger.info("creating_jira_ticket", file=python_file)

        try:
            async with httpx.AsyncClient() as client:
                ticket_data = {
                    "fields": {
                        "project": {"key": self.jira_project},
                        "summary": f"Write test cases for {python_file}",
                        "description": {
                            "type": "doc",
                            "version": 1,
                            "content": [
                                {
                                    "type": "paragraph",
                                    "content": [
                                        {
                                            "type": "text",
                                            "text": f"Write comprehensive test cases for {python_file} in repository {repo}"
                                        }
                                    ]
                                },
                                {
                                    "type": "heading",
                                    "attrs": {"level": 3},
                                    "content": [{"type": "text", "text": "Requirements"}]
                                },
                                {
                                    "type": "bulletList",
                                    "content": [
                                        {
                                            "type": "listItem",
                                            "content": [{
                                                "type": "paragraph",
                                                "content": [{"type": "text", "text": "Unit tests with pytest"}]
                                            }]
                                        },
                                        {
                                            "type": "listItem",
                                            "content": [{
                                                "type": "paragraph",
                                                "content": [{"type": "text", "text": "Minimum 80% code coverage"}]
                                            }]
                                        },
                                        {
                                            "type": "listItem",
                                            "content": [{
                                                "type": "paragraph",
                                                "content": [{"type": "text", "text": "Test all public methods"}]
                                            }]
                                        },
                                        {
                                            "type": "listItem",
                                            "content": [{
                                                "type": "paragraph",
                                                "content": [{"type": "text", "text": "Mock external dependencies"}]
                                            }]
                                        },
                                        {
                                            "type": "listItem",
                                            "content": [{
                                                "type": "paragraph",
                                                "content": [{"type": "text", "text": "Test edge cases and error handling"}]
                                            }]
                                        }
                                    ]
                                },
                                {
                                    "type": "heading",
                                    "attrs": {"level": 3},
                                    "content": [{"type": "text", "text": "Context"}]
                                },
                                {
                                    "type": "paragraph",
                                    "content": [
                                        {
                                            "type": "text",
                                            "text": f"Related to incident: {incident_id}\n"
                                        },
                                        {
                                            "type": "text",
                                            "text": f"Repository: https://github.com/{repo}\n"
                                        },
                                        {
                                            "type": "text",
                                            "text": f"File: {python_file}"
                                        }
                                    ]
                                }
                            ]
                        },
                        "issuetype": {"name": "Task"},
                        "priority": {"name": "Medium"},
                        "labels": ["testing", "automated", "incident-related"]
                    }
                }

                response = await client.post(
                    f"{self.jira_url}/rest/api/3/issue",
                    auth=(self.jira_username, self.jira_token),
                    headers={"Content-Type": "application/json"},
                    json=ticket_data,
                    timeout=30
                )

                if response.status_code == 201:
                    result = response.json()
                    return {
                        "success": True,
                        "ticket_key": result["key"],
                        "ticket_url": f"{self.jira_url}/browse/{result['key']}"
                    }
                else:
                    return {
                        "success": False,
                        "error": f"Status {response.status_code}: {response.text}"
                    }

        except Exception as e:
            logger.error("jira_ticket_error", error=str(e))
            return {"success": False, "error": str(e)}

    def _encode_base64(self, content: str) -> str:
        """Encode content to base64 for GitHub API"""
        import base64
        return base64.b64encode(content.encode()).decode()


# Global instance
solution_generator = DynamicSolutionGenerator()
