{
  "version": "2.0.0",
  "last_updated": "2025-11-28",
  "description": "Enterprise Script Registry - Source of Truth for Safe Automation",
  "execution_mode": "pipeline_only",
  "pipeline_config": {
    "ansible": {
      "workflow": "ansible-execute.yml",
      "runner": "github_actions"
    },
    "terraform": {
      "workflow": "terraform-execute.yml",
      "runner": "github_actions",
      "state_backend": "gcs"
    },
    "shell": {
      "workflow": "shell-execute.yml",
      "runner": "github_actions"
    },
    "kubernetes": {
      "workflow": "kubernetes-execute.yml",
      "runner": "github_actions"
    }
  },
  "scripts": [
    {
      "id": "ansible-restart-kubernetes-pod",
      "name": "Restart Kubernetes Pod",
      "type": "ansible",
      "service": "kubernetes",
      "category": "container",
      "component": "pod",
      "action": "restart",
      "description": "Restarts a Kubernetes pod to recover from crashes or memory issues",
      "path": "ansible/restart_kubernetes_pod.yml",
      "workflow": "ansible-execute.yml",
      "keywords": ["pod", "restart", "crashloop", "oom", "killed", "kubernetes", "k8s"],
      "error_patterns": ["pod.*crash", "crashloopbackoff", "oomkilled", "container.*restart"],
      "risk_level": "low",
      "auto_approve": true,
      "environment_allowed": ["development", "staging", "production"],
      "required_inputs": ["namespace", "pod_name"],
      "optional_inputs": ["timeout", "grace_period"],
      "rollback_script": "ansible-check-pod-status",
      "owner_team": "platform-team",
      "dependencies": ["kubernetes-cluster-access"],
      "estimated_duration_seconds": 60,
      "tags": ["kubernetes", "pod", "restart", "recovery"],
      "success_indicators": ["pod_running", "health_check_passed"],
      "failure_indicators": ["pod_crashloopbackoff", "image_pull_error"],
      "pre_checks": ["verify_kubectl", "get_pod_status"],
      "post_checks": ["verify_pods_running", "check_pod_logs"]
    },
    {
      "id": "ansible-restart-nginx",
      "name": "Restart Nginx Web Server",
      "type": "ansible",
      "service": "web",
      "category": "service",
      "component": "nginx",
      "action": "restart",
      "description": "Restarts Nginx web server to apply configuration changes or recover",
      "path": "ansible/restart_nginx.yml",
      "workflow": "ansible-execute.yml",
      "keywords": ["nginx", "web", "server", "502", "504", "gateway", "timeout"],
      "error_patterns": ["502.*bad.*gateway", "504.*gateway.*timeout", "nginx.*not.*running"],
      "risk_level": "low",
      "auto_approve": true,
      "environment_allowed": ["development", "staging", "production"],
      "required_inputs": ["target_host"],
      "optional_inputs": ["config_test_first"],
      "rollback_script": "ansible-nginx-status-check",
      "owner_team": "web-team",
      "dependencies": ["ssh-access"],
      "estimated_duration_seconds": 30,
      "tags": ["nginx", "web", "restart", "service"],
      "success_indicators": ["service_active", "port_listening"],
      "failure_indicators": ["config_error", "service_failed"],
      "pre_checks": ["verify_nginx_config", "check_nginx_status"],
      "post_checks": ["verify_nginx_running", "verify_ports_listening"]
    },
    {
      "id": "ansible-restart-airflow-scheduler",
      "name": "Restart Airflow Scheduler",
      "type": "ansible",
      "service": "airflow",
      "category": "orchestration",
      "component": "scheduler",
      "action": "restart",
      "description": "Restarts Airflow scheduler to recover from stuck DAGs or memory issues",
      "path": "ansible/restart_airflow_scheduler.yml",
      "workflow": "ansible-execute.yml",
      "keywords": ["scheduler", "heartbeat", "down", "missing", "restart", "airflow", "dag"],
      "error_patterns": ["scheduler.*heartbeat.*missing", "scheduler.*down", "airflow.*scheduler.*not.*respond"],
      "risk_level": "medium",
      "auto_approve": false,
      "environment_allowed": ["development", "staging", "production"],
      "required_inputs": ["airflow_host"],
      "optional_inputs": ["clear_task_instances"],
      "rollback_script": "ansible-airflow-status-check",
      "owner_team": "data-team",
      "dependencies": ["ssh-access", "airflow-access"],
      "estimated_duration_seconds": 120,
      "tags": ["airflow", "scheduler", "restart", "data-pipeline"],
      "success_indicators": ["scheduler_running", "dags_parsed"],
      "failure_indicators": ["db_connection_error", "scheduler_not_running"],
      "pre_checks": ["verify_airflow_installed", "check_scheduler_status"],
      "post_checks": ["verify_process_running", "verify_heartbeat"]
    },
    {
      "id": "ansible-fix-database-cpu",
      "name": "Fix Database High CPU",
      "type": "ansible",
      "service": "database",
      "category": "performance",
      "component": "postgresql",
      "action": "optimize",
      "description": "Identifies and terminates long-running queries causing high CPU",
      "path": "ansible/fix_database_cpu.yml",
      "workflow": "ansible-execute.yml",
      "keywords": ["database", "cpu", "high", "spike", "slow", "queries", "postgresql"],
      "error_patterns": ["database.*cpu.*high", "slow.*query", "query.*timeout", "connection.*pool.*exhausted"],
      "risk_level": "medium",
      "auto_approve": false,
      "environment_allowed": ["development", "staging", "production"],
      "required_inputs": ["db_host", "db_name"],
      "optional_inputs": ["query_timeout_seconds", "kill_blocking_queries"],
      "rollback_script": null,
      "owner_team": "dba-team",
      "dependencies": ["db-admin-access"],
      "estimated_duration_seconds": 180,
      "tags": ["database", "cpu", "performance", "postgresql"],
      "success_indicators": ["cpu_normalized", "queries_terminated"],
      "failure_indicators": ["connection_refused", "permission_denied"],
      "pre_checks": ["capture_cpu", "identify_long_queries"],
      "post_checks": ["verify_cpu_reduced", "verify_db_responding"]
    },
    {
      "id": "ansible-flush-redis-cache",
      "name": "Flush Redis Cache",
      "type": "ansible",
      "service": "cache",
      "category": "cache",
      "component": "redis",
      "action": "flush",
      "description": "Flushes Redis cache to clear stale data or resolve memory issues",
      "path": "ansible/flush_redis_cache.yml",
      "workflow": "ansible-execute.yml",
      "keywords": ["redis", "cache", "flush", "clear", "memory", "stale"],
      "error_patterns": ["cache.*stale", "redis.*memory.*full", "cache.*inconsistent"],
      "risk_level": "medium",
      "auto_approve": false,
      "environment_allowed": ["development", "staging"],
      "required_inputs": ["redis_host"],
      "optional_inputs": ["database_number", "pattern"],
      "rollback_script": null,
      "owner_team": "platform-team",
      "dependencies": ["redis-access"],
      "estimated_duration_seconds": 30,
      "tags": ["redis", "cache", "flush", "memory"],
      "success_indicators": ["cache_cleared", "memory_freed"],
      "failure_indicators": ["connection_refused", "auth_failed"],
      "pre_checks": ["verify_redis_running", "capture_memory_usage"],
      "post_checks": ["verify_cache_cleared", "verify_redis_responding"]
    },
    {
      "id": "ansible-scale-gcp-instance",
      "name": "Scale GCP VM Instance",
      "type": "ansible",
      "service": "gcp",
      "category": "compute",
      "component": "vm",
      "action": "scale",
      "description": "Scales GCP VM instance to larger machine type for performance",
      "path": "ansible/scale_gcp_instance.yml",
      "workflow": "ansible-execute.yml",
      "keywords": ["gcp", "vm", "instance", "scale", "resize", "memory", "cpu"],
      "error_patterns": ["instance.*out.*of.*memory", "vm.*memory.*exhausted", "cpu.*throttled"],
      "risk_level": "high",
      "auto_approve": false,
      "environment_allowed": ["development", "staging"],
      "required_inputs": ["instance_name", "zone", "new_machine_type"],
      "optional_inputs": ["project"],
      "rollback_script": "ansible-revert-gcp-instance-type",
      "owner_team": "infrastructure-team",
      "dependencies": ["gcp-compute-admin"],
      "estimated_duration_seconds": 300,
      "tags": ["gcp", "vm", "scale", "compute"],
      "success_indicators": ["instance_running", "new_type_applied"],
      "failure_indicators": ["quota_exceeded", "instance_not_found"],
      "pre_checks": ["verify_gcloud_auth", "capture_current_type"],
      "post_checks": ["verify_instance_running", "verify_new_specs"]
    },
    {
      "id": "script-start-gcp-instance",
      "name": "Start GCP VM Instance",
      "type": "shell",
      "service": "gcp",
      "category": "compute",
      "component": "vm",
      "action": "start",
      "description": "Starts a stopped GCP VM instance",
      "path": "scripts/start_gcp_instance.sh",
      "workflow": "shell-execute.yml",
      "keywords": ["gcp", "vm", "instance", "start", "terminated", "stopped", "boot"],
      "error_patterns": ["instance.*terminated", "instance.*stopped", "vm.*not.*running"],
      "risk_level": "low",
      "auto_approve": true,
      "environment_allowed": ["development", "staging", "production"],
      "required_inputs": ["instance_name", "zone"],
      "optional_inputs": ["project", "wait_for_running"],
      "rollback_script": "script-stop-gcp-instance",
      "owner_team": "infrastructure-team",
      "dependencies": ["gcp-compute-access"],
      "estimated_duration_seconds": 120,
      "tags": ["gcp", "vm", "start", "compute"],
      "success_indicators": ["instance_running", "ssh_available"],
      "failure_indicators": ["instance_not_found", "quota_exceeded"],
      "pre_checks": ["verify_gcloud_auth", "verify_instance_exists"],
      "post_checks": ["verify_instance_running", "verify_network_connectivity"]
    },
    {
      "id": "script-stop-gcp-instance",
      "name": "Stop GCP VM Instance",
      "type": "shell",
      "service": "gcp",
      "category": "compute",
      "component": "vm",
      "action": "stop",
      "description": "Stops a running GCP VM instance",
      "path": "scripts/stop_gcp_instance.sh",
      "workflow": "shell-execute.yml",
      "keywords": ["gcp", "vm", "instance", "stop", "shutdown"],
      "error_patterns": [],
      "risk_level": "medium",
      "auto_approve": false,
      "environment_allowed": ["development", "staging"],
      "required_inputs": ["instance_name", "zone"],
      "optional_inputs": ["project"],
      "rollback_script": "script-start-gcp-instance",
      "owner_team": "infrastructure-team",
      "dependencies": ["gcp-compute-access"],
      "estimated_duration_seconds": 60,
      "tags": ["gcp", "vm", "stop", "compute"],
      "success_indicators": ["instance_terminated"],
      "failure_indicators": ["instance_not_found"],
      "pre_checks": ["verify_gcloud_auth", "verify_instance_exists"],
      "post_checks": ["verify_instance_stopped"]
    },
    {
      "id": "script-clear-disk-space",
      "name": "Clear Disk Space",
      "type": "shell",
      "service": "linux",
      "category": "storage",
      "component": "disk",
      "action": "cleanup",
      "description": "Clears temporary files, old logs, and package cache to free disk space",
      "path": "scripts/clear_disk_space.sh",
      "workflow": "shell-execute.yml",
      "keywords": ["disk", "space", "full", "cleanup", "logs", "temp", "storage"],
      "error_patterns": ["disk.*full", "no.*space.*left", "filesystem.*full"],
      "risk_level": "low",
      "auto_approve": true,
      "environment_allowed": ["development", "staging", "production"],
      "required_inputs": ["target_host"],
      "optional_inputs": ["retention_days", "paths_to_clean"],
      "rollback_script": null,
      "owner_team": "platform-team",
      "dependencies": ["ssh-access", "sudo-access"],
      "estimated_duration_seconds": 180,
      "tags": ["disk", "cleanup", "storage", "linux"],
      "success_indicators": ["disk_space_freed", "cleanup_complete"],
      "failure_indicators": ["permission_denied", "no_space_left"],
      "pre_checks": ["check_disk_usage", "identify_large_directories"],
      "post_checks": ["verify_space_freed", "verify_disk_below_threshold"]
    },
    {
      "id": "terraform-create-firewall-rule",
      "name": "Create GCP Firewall Rule",
      "type": "terraform",
      "service": "gcp",
      "category": "network",
      "component": "firewall",
      "action": "create",
      "description": "Creates a new GCP firewall rule for network access",
      "path": "terraform/gcp_firewall_allow.tf",
      "workflow": "terraform-execute.yml",
      "keywords": ["firewall", "network", "security", "ingress", "egress", "port"],
      "error_patterns": ["connection.*timed.*out", "network.*unreachable", "port.*blocked"],
      "risk_level": "critical",
      "auto_approve": false,
      "environment_allowed": ["development", "staging"],
      "required_inputs": ["rule_name", "network", "allowed_ports", "source_ranges"],
      "optional_inputs": ["priority", "target_tags"],
      "rollback_script": "terraform-delete-firewall-rule",
      "owner_team": "security-team",
      "dependencies": ["gcp-network-admin", "security-review"],
      "estimated_duration_seconds": 60,
      "tags": ["gcp", "firewall", "network", "security"],
      "success_indicators": ["rule_created", "traffic_allowed"],
      "failure_indicators": ["rule_conflict", "invalid_range"],
      "pre_checks": ["terraform_plan", "verify_network_exists"],
      "post_checks": ["verify_rule_created", "test_connectivity"]
    },
    {
      "id": "terraform-scale-gcp-instance-group",
      "name": "Scale GCP Instance Group",
      "type": "terraform",
      "service": "gcp",
      "category": "compute",
      "component": "instance-group",
      "action": "scale",
      "description": "Scales a GCP managed instance group to handle load",
      "path": "terraform/scale_instance_group.tf",
      "workflow": "terraform-execute.yml",
      "keywords": ["gcp", "instance-group", "scale", "autoscaling", "load"],
      "error_patterns": ["high.*load", "response.*time.*slow", "queue.*backed.*up"],
      "risk_level": "high",
      "auto_approve": false,
      "environment_allowed": ["development", "staging", "production"],
      "required_inputs": ["instance_group_name", "zone", "target_size"],
      "optional_inputs": ["max_surge", "max_unavailable"],
      "rollback_script": "terraform-scale-gcp-instance-group",
      "owner_team": "infrastructure-team",
      "dependencies": ["gcp-compute-admin"],
      "estimated_duration_seconds": 300,
      "tags": ["gcp", "instance-group", "scale", "autoscaling"],
      "success_indicators": ["instances_created", "health_checks_passing"],
      "failure_indicators": ["quota_exceeded", "template_error"],
      "pre_checks": ["verify_instance_group_exists", "capture_current_size"],
      "post_checks": ["verify_new_size", "check_health"]
    },
    {
      "id": "k8s-restart-deployment",
      "name": "Restart Kubernetes Deployment",
      "type": "kubernetes",
      "service": "kubernetes",
      "category": "container",
      "component": "deployment",
      "action": "restart",
      "description": "Performs a rolling restart of a Kubernetes deployment",
      "path": "kubernetes/restart_deployment.yaml",
      "workflow": "kubernetes-execute.yml",
      "keywords": ["kubernetes", "k8s", "deployment", "restart", "pods", "rolling"],
      "error_patterns": ["pod.*crash", "container.*error", "deployment.*unhealthy"],
      "risk_level": "low",
      "auto_approve": true,
      "environment_allowed": ["development", "staging", "production"],
      "required_inputs": ["namespace", "deployment_name"],
      "optional_inputs": ["max_unavailable", "max_surge"],
      "rollback_script": "k8s-rollback-deployment",
      "owner_team": "platform-team",
      "dependencies": ["kubernetes-cluster-access"],
      "estimated_duration_seconds": 180,
      "tags": ["kubernetes", "deployment", "restart", "rolling"],
      "success_indicators": ["pods_ready", "rollout_complete"],
      "failure_indicators": ["pods_crashloopbackoff", "image_pull_error"],
      "pre_checks": ["verify_deployment_exists", "check_current_pods"],
      "post_checks": ["verify_pods_running", "check_rollout_status"]
    },
    {
      "id": "k8s-scale-deployment",
      "name": "Scale Kubernetes Deployment",
      "type": "kubernetes",
      "service": "kubernetes",
      "category": "container",
      "component": "deployment",
      "action": "scale",
      "description": "Scales a Kubernetes deployment to specified replica count",
      "path": "kubernetes/scale_deployment.yaml",
      "workflow": "kubernetes-execute.yml",
      "keywords": ["kubernetes", "k8s", "scale", "replicas", "deployment", "load"],
      "error_patterns": ["high.*load", "response.*time.*slow", "replicas.*insufficient"],
      "risk_level": "medium",
      "auto_approve": false,
      "environment_allowed": ["development", "staging", "production"],
      "required_inputs": ["namespace", "deployment_name", "replicas"],
      "optional_inputs": [],
      "rollback_script": "k8s-scale-deployment",
      "owner_team": "platform-team",
      "dependencies": ["kubernetes-cluster-access"],
      "estimated_duration_seconds": 120,
      "tags": ["kubernetes", "deployment", "scale", "replicas"],
      "success_indicators": ["desired_replicas_met", "pods_ready"],
      "failure_indicators": ["resource_quota_exceeded", "pending_pods"],
      "pre_checks": ["verify_deployment_exists", "check_current_replicas"],
      "post_checks": ["verify_replicas_running", "check_pod_health"]
    }
  ],
  "risk_levels": {
    "low": {
      "description": "Low risk - minimal impact, easily reversible",
      "auto_approve_allowed": true,
      "approval_count": 0,
      "environments": ["development", "staging", "production"]
    },
    "medium": {
      "description": "Medium risk - potential service impact, requires review",
      "auto_approve_allowed": false,
      "approval_count": 1,
      "environments": ["development", "staging", "production"]
    },
    "high": {
      "description": "High risk - significant impact, requires senior approval",
      "auto_approve_allowed": false,
      "approval_count": 2,
      "environments": ["development", "staging"]
    },
    "critical": {
      "description": "Critical risk - major infrastructure change, requires manager approval",
      "auto_approve_allowed": false,
      "approval_count": 2,
      "environments": ["development", "staging"],
      "requires_manager_approval": true
    }
  },
  "matching_algorithm": {
    "weights": {
      "vector_score": 0.50,
      "metadata_score": 0.25,
      "graph_score": 0.15,
      "safety_score": 0.10
    },
    "minimum_final_score": 0.75,
    "minimum_vector_score": 0.70
  },
  "safety_rules": {
    "production_restrictions": [
      "Only production-allowed scripts can execute in production",
      "High-risk scripts never auto-approve in production",
      "Critical scripts require manager approval in all environments"
    ],
    "mandatory_checks": [
      "required_inputs_present",
      "rollback_exists_for_high_risk",
      "dependency_graph_valid",
      "environment_allowed"
    ],
    "forbidden_actions": [
      "direct_terraform_apply",
      "direct_ansible_playbook",
      "ssh_manual_execution",
      "state_file_in_git"
    ]
  }
}
